\newpage
\chapter{Programmieraufgaben}
\vspace{-15 pt}
Der Quellcode für der einzelnen Aufgabenteile ist im git-Repo zu finden. Nachfolgend sollen die Grundkonzepte und die Verwendung der entwickelten Anwendungen geschildert werden.
\vspace{-15 pt}
\section{Sockets}
\vspace{-15 pt}
Ein Socket ist eine Softwarestruktur, die zur Netzwerkkommunikation verwendet wird. Darüber hinaus werden Sockets auch zur Interprozesskommunikation eingesetzt. Darauf wird in der zweiten Aufgabe detaillierter eingegangen. Sockets sind bidirektional und der jeweilige Endpunkt des Kommunikationskanals. Über diesen Kanal können Anfragen gesendet und auch die entsprechenden Antworten empfangen werden. Client und Server besitzen einen eigenen Socket, dieser besteht aus Ziel- bzw. Quell-IP-Adresse, Ziel- bzw. Quellport sowie dem zu verwendenden Protokoll \cite{2009:rhein}.
\vspace{-15 pt}
\subsection{Teilaufgabe A}
\vspace{-15 pt}
In Teilaufgabe A wird die Grundstruktur für eine Socketkommunkation aufgebaut. Der Server soll bei Empfang eines PING Kommandos dem Client mit einem PONG antworten. 

Es wird unter der eigenen IP-Adresse (localhost) ein Socket erstellt. Dazu wird weiterhin ein Port benötigt, der im Quellcode vorgegeben wird. In diesem Beispiel wird der Port 12345 genutzt. Nach der Socketerstellung wartet der Server auf eine eingehende Verbindung. Verbindet sich ein Client wird die Chat-Funktion aufgerufen. Eine eingehende Nachricht wird in einem Buffer gespeichert, ausgewertet und in der Kommandozeile ausgegeben. Getestet werden kann dieser einfache Server mit netcat:
\begin{lstlisting}
nc localhost 12345
\end{lstlisting}
\vspace{-15 pt}
Die Eingabe von PING im netcat Terminal sendet die Nachricht an den Server. Als Antwort wird ein PONG gesendet. Alle sonstigen Nachrichten werden in der Kommandozeile des Servers angezeigt, aber nicht beantwortet.
\subsection{Teilaufgabe B}
\vspace{-15 pt}
Im zweiten Aufgabenteil wird eine eigene Client Anwendung entwickelt. Außerdem wird der Server erweitert, sodass er mehrere Clienten verwalten kann. Über Fork wird jede Clientverbindung in einen neuen Kindprozess ausgelagert. Dort wird dann die Chatfunktion wie in Aufgabenteil A ausgeführt. Der Hauptprozess kann dann weiterhin neue Verbindungen akzeptieren, da er nicht mehr durch die Bearbeitung der Chatfunktion blockiert ist.

Die Clientanwendung nutzt die gleichen Bibliotheken wie der Server. Es wird ein eigener Socket erstellt und anschließend eine Verbindung zum Server aufgebaut. IP und der Port des Servers werden im Quellcode vorgegeben. Bei mehreren Servern ist es sinnvoll den Code um eine Nutzereingabe zu ergänzen, die IP und PORT abfragt, wie es auch bei netcat umgesetzt ist.\\
Nach einer erfolgreichen Verbindung zum Server wartet das Clientprogramm auf eine Nutzereingabe und sendet diese an den Server. Gibt der Nutzer QUIT ein, wird die Verbindung vom Client geschlossen. Alle eventuellen Antworten vom Server werden auf der Kommandozeile ausgegeben. Die erstellte Clientanwendung kann mehrmals gestartet werden. Alle gestarteten Instanzen können Nachrichten an den Server senden und erhalten bei einem PING Kommando auch ein PONG.
\vspace{-15 pt}
\subsection{Teilaufgabe C}
\vspace{-15 pt}
Für die Implementierung der editierbaren Listenfunktion müssen neue Befehle im Server angelegt werden. Im Server wird ein Log eingeführt, dass alle ein und ausgehenden Nachrichten mit einem Zeitstempel abspeichert. Der Client kann dann das Log vom Server anfordern und den Text von einzelnen Einträgen verändern. Geänderte Einträge werden im Log markiert.\\
Die Behandlung des Log wird in einer eigenen Funktion umgesetzt und die bisherige Chat Funktion wird zur comm Funktion. Das Log besteht aus einem Array in dem insgesamt 100 Nachrichten gespeichert werden können. Die Log Funktion wird bei Empfang einer neuen Nachricht bzw. beim Versenden einer Antwort aufgerufen. Der Nutzer kann über GETLOG die Liste anfordern, EDITLOG \textit{id} \textit{text} bearbeitet den angegebenen Eintrag.\\
Dadurch das für die Übertragung des Logs mehrere Nachrichten vom Server nacheinander gesendet werden müssen, muss der Nachrichtenempfang im Client geändert werden. Bisher erfolgt immer ein Wechsel zwischen senden und empfangen. Der Empfang wird um ein Timeout erweitert. Trifft 200 ms keine Nachricht mehr beim Client ein, wird zur Eingabe übergegangen. Dies funktioniert im lokalen Netzwerk ohne Probleme. Sollen die Anwendungen über größere Entfernungen kommunizieren muss der Timeout erhöht oder ein anderes Konzept verwendet werden, die aktuelle Variante ist nur für kurze Nachrichtenlaufzeiten geeignet.
\vspace{-15 pt}
\newpage
\subsection{Teilaufgabe D}
\vspace{-15 pt}
In der Teilaufgabe D wird die Server-Client Architektur in eine Peer-to-Peer Kommunikation umgewandelt. Für die Sockets wird weiterhin ein Verwalter benötigt. Der erste Aufruf der Anwendung startet den Serversocket. Im gleichen Terminal kann dann noch eine Clientverbindung aufgebaut werden, die die bekannten Befehle ausführen kann. Jeder weitere Aufruf gibt gibt den Hinweis zurück, dass der Serversocket nicht erstellt werden konnte, da dieser schon belegt ist. Danach kann die Verbindung zum anderen Partner aufgebaut werden. Mit einem CONNECT \textit{ip} kann die Verbindung hergestellt werden. Alternativ kann mit EXIT die Anwendung beendet werden.

Mit Threads werden die einzelnen zu erledigenden Aufgaben parallel ausgeführt. Der Serverthread wird nur vom ersten Aufruf gestartet, dort wird auch die bereits vorhanden comm Funktion aufgerufen. Alle weiteren Instanzen starten den Inputthread, der die Verbindungen zum Server aufbaut. Der Thread ruft dann eine Clientfunktion auf, die das bisherige separate Programm ersetzt.
\vspace{-15 pt}
\newpage
\section{Interprozesskommunikation}
\vspace{-15 pt}
Für die IPC können mehrere Varianten gewählt werden. Für die Bearbeitung der nachfolgenden Aufgaben wurden Message Queues verwendet.

Message Queues verwalten Nachrichten wie verkettetet Listen. Die Listen verfügen über eine Kennung durch die sie durch Prozesse identifiziert werden können. Von einem Prozess gesendete Nachrichten werden gespeichert und können vom Partnerprozess abgerufen werden. Der Prozess kann seinerseits auch Nachrichten in der Queue ablegen. Standardmäßig arbeiten die Queues nach dem FIFO-Prinzip. Es gibt jedoch die Möglichkeit Nachrichten zu priorisieren, indem man ihnen einen eigenen Nachrichtentyp zuweist. Der Prozess sucht dann in der Liste nach der ersten Nachricht dieses Typs auch wenn sie ganz am Ende der Queue stehen sollte \cite{2009:rhein}.
\vspace{-15 pt}
\subsection{Teilaufgabe A und B}
\vspace{-15 pt}
Diese Teilaufgaben erstellen die Grundstruktur für die Kommunikation. Für den Test des Mainprozess wird ein Subscriberprozess geschrieben, sodass die Aufgaben A und B gemeinsam gelöst werden.

Von der main-Anwendung wird eine Queue geöffnet über die die Subscriberprozesse den Hauptprozess erreichen können. Zum öffnen einer Queue wird ein eindeutiger Schlüssel benötigt. Der Funktion werden außerdem die Berechtigungen mitgegeben, die die geöffnete Queue haben soll. Bei Bedarf können so Listen erstellt werden, die nur gelesen werden können. Subscriber können dann über diesen Kanal keine Nachrichten senden. Die main-Anwendung wartet in einer Schleife auf eine neue Nachricht in der Queue. Die abgerufen Nachricht wird in einer Struktur gespeichert, die den Nachrichtentyp und den eigentlichen Nachrichtentext enthält. Der Nachrichtentext wird anschließend auf bestimmte Kommandos geprüft. Auf eine PING Nachricht wird mit einem PONG an den Subscriber geantwortet.

Die Subscriberanwedung greift auf die erstellte Queue von main zu. Der Nutzer kann über die Kommandozeile eine Nachricht eingeben, die dann in die Queue gesetzt wird. Eine Antworten des Hauptprozesses werden in der Kommandozeile ausgegeben.
\vspace{-15 pt}
\subsection{Teilaufgabe C}
\vspace{-15 pt}
Die bestehende Struktur aus Hauptanwendung und Subscribern wird nun so erweitert, das jeder Subscriber eine eigene Queue öffnet über die er exklusiv mit der Hauptanwendung kommuniziert. Dazu wird in der Nachricht noch die Queue-ID des Clients übertragen, an die dann die Antwort erfolgt.\\
Zusätzlich wird noch ein Nachrichtenlog implementiert wie es auch in der Socketaufgabe verwendet wurde. Die Befehle werden nach dem gleichen Schema implementiert. Die Subscribersoftware muss so angepasst werden, dass mehrere Nachrichten in Folge abgerufen werden, bis die Queue leer ist. Dies ist so gestaltet, dass das abrufen nicht blockiert, also ebenfalls noch Nutzereingaben gemacht werden können. Die Bibliothek für die Queues stellt die benötigte Funktion bereit, sodass nicht mit Timeouts gearbeitet wird.
\vspace{-15 pt}
\subsection{Teilaufgabe D}
\vspace{-15 pt}
Abschließend wird die Struktur in eine Peer-to-Peer Kommunikation umgewandelt, sodass die Partner die gleichen Funktionen besitzen. Es gibt keine Hauptanwendung mehr, die die Kommunikation verwaltet. Beim Ausführen der Anwendung muss zum Start ein eindeutiger Schlüssel angegeben werden. Dieser war in den vorherigen Teilaufgaben immer fest definiert.
\begin{lstlisting}
.\peer 123
.\peer 456
\end{lstlisting} 
\vspace{-15 pt}
Es wird der receive-Thread gestartet, der Nachrichten aus der Queue abruft und auf bestimmte Befehle prüft. Über die Befehle werden Funktionen aufgerufen wie z.B. PING oder das Anfordern und Bearbeiten einer Liste. In dieser Anwendung wird keine Log abgerufen wie bisher sondern eine von den Nutzern erstellte Liste, die lokal oder remote beim Kommunikationspartner geändert werden kann. Wie die Liste des Partners angefordert überschriebt dies immer die eigene lokale Liste. Zum Senden eines Befehls muss der Schlüssel der Gegenstelle an den Befehl an gehangen werden. Der eigene Schlüssel wendet den Befehl dann lokal an. Folgende Befehle können verwendet werden:
\begin{itemize}
\item ADD \textit{item}	fügt das eingegebene Element der eigenen Liste hinzu
\item UPDATE \textit{id newitem} ändert den angegeben Eintrag
\item SHOW gibt die Liste aus
\item GETLIST \textit{key} fordert die Liste des Partners an
\item SEND \textit{key message} sendet dem angegebenen Partner die Nachricht. Mit SEND kann auch ein ADD an den Partner übertragen werden
\item PING \textit{key} sendet ein PING an den Partner 
\end{itemize}